

# JavaScript SDK

## Introduction

**Introducing the Revolutionary Handpoint JavaScript SDK: Seamlessly integrate card present payments into any cloud software**
Use the Handpoint JavaScript SDK to integrate leading smartpos terminals with your cloud software. The Handpoint JavaScript SDK is a simple javascript interface running in your web application that acts as a bridge between the web browser and the payment terminal, while shielding your software from card data. It is seamless to integrate, keeps all card data out of your system, works with every platform, and lets you use the best Android terminals on the market.

Complete your integration in just three steps: Initiate the interface, choose the terminal, and start the sale. It is as simple as it sounds. The only thing you need is a valid API key to initialize the SDK. You even get a list of terminals to which you can connect. Simply execute the operation, and within seconds you’ll get back the transaction result and receipt in your software all while you monitor the transaction status. The Handpoint JavaScript SDK seamlessly starts and manages the entire P2PE transaction with the payment terminal, minimizing hassle for you and maximizing reliability, security, and control.

For your merchants, the terminal setup is easier than a standalone. A merchant connects the terminal to their network, just like a smartphone, authenticates his/her account, and it simply works -- your software then control the terminal from anywhere in the world, and your merchants have secure, reliable, intuitive payments.

## Release Notes

**5.0.0**

**BREAKING CHANGE:**
- A new interface for optional parameters is available. The usage of an object was introduced to contain optional parameters such as the customer reference, tip configuration, bypass options or multi mid credentials.

**Features:**

- Pin and signature bypass.
- Multi-mid

## API Overview

This API flow shows how easy it is to add card present payments to your cloud application. The interaction between your cloud application and the Handpoint JavaScript SDK is simple and streamlined. The Handpoint JavaScript SDK takes care of all of the communication with the terminal. The status messages are received in the WEB APP via the callback function defined in the Financial Operation requests call. That’s it.

The Handpoint JavaScript SDK shields your software from all sensitive cardholder data. With Handpoint JavaScript SDK, the transaction request goes from your software to Handpoint in the cloud. We steer the terminal from the cloud. All of the results come to your software via Handpoint in the cloud.

![Sandbox logo](/img/overview.png)

## Configuration

Getting started with the SDK is **fast and easy**. Simply download the Javascript SDK from here. Request a valid API key to start using the SDK and all of its functionalities. Initialize the SDK with your API key and receive the list of devices available to perform the sale.

## Sandbox

Get started today with our sandbox. You can generate sample transactions and test the experience right in your browser. Check it at: http://www.handpoint.com/lab/cloudpos. A payment terminal is required to start testing.
Get started today with our sandbox. You can generate sample transactions and test the experience right in your browser. Check it at: http://www.handpoint.com/lab/cloudpos. A payment terminal is required to start testing.

This is the initial setup screen:

![Sandbox logo](/img/cloudpos.png)

To get started, select the target environment where you are going to operate (Sandbox/Production). If the user has any doubts selecting the correct environment, click on  "*How do I know what type of card reader do I have?*" and you will be redirected to an explanation page.

![Sandbox logo](/img/cloudpos2.png)

Next, enter your Handpoint API key in the box labeled "*INSERT API KEY*” and click the check button. This will automatically populate the “*SELECT A DEVICE*” drop down with the list of devices that are assigned to you. If the API key is not valid, an error message will appear in the “RESPONSES” section of the sandbox.

![Sandbox logo](/img/cloudpos3.png)

Before you can begin any further testing, you first must select the device that you will be using. In the “*SELECT A DEVICE*” list, you will see both the real terminals assigned to you, as well as simulated devices (listed by serial number). You can choose any device to test with. Serial numbers for the simulated devices always have this format: XXXX | 999999xxxxx. Choose a simulated terminal if you do not have access to a real device or if you just want to see simulated behavior. You can refresh the “*SELECT A DEVICE*” list by clicking the refresh button on the right side of the “*SELECT A DEVICE*” box. If you are already connected to a device, you can disconnect from it using the “*Disconnect*” button or trigger a software and configuration update operation by using the "*Update*" button.

![Sandbox logo](/img/cloudpos4.png)

Once you have selected a device, the “SELECT A DEVICE” box will be disabled, and the rest of the sandbox will be enabled. With your selected device, you can simulate a number of operations, including:

- sale
- sale and tokenize
- refund
- tokenize card
- reverse sale transactions
- reverse refund transactions

In order to reverse a transaction, a transaction id is needed, this id is available in the transaction result data coming from a previous sale or refund operation. Each transaction result will appear in the RESPONSES panel, on the right side of the screen.

With each transaction result you will be able to perform several operations:
- View and print the merchant receipt
- View and print the customer receipt
- Reverse the transaction
- Copy the transaction result data; it is the raw transaction result, as received by the application from the device

![Sandbox logo](/img/cloudpos5.png)

## Processing Payments Simulation

Test transactions are conducted against a test server which is designed to simulate the behavior of an acquiring bank without moving any funds. As with every Handpoint terminal, sensitive card data is fully encrypted.

Use trigger amounts to generate some specific responses from our server:

**Sale amounts**

| Amount      | Behaviour |
| ----------- | ----------- |
| 37.79      | Issuer response code = 01 (Refer to issuer)       |
| 37.84      | Issuer response code = 05 (Not authorized)        |
| 37.93      | Issuer response code = 04 (Pick up card)       |
| 37.57      | Request is partially approved        |
| 37.68      | Request timeout       |

## Quick Integration Test

This js script sample shows how you can integrate your solution with Handpoint JavaScript SDK to perform a product sale in three quick and simple SDK calls:

1) Request your test configuration (apiKey and deviceName constants) from Handpoint and set them in your web application

2) Download handpoint.js from this link

3) In the same directory, copy both handpoint.js and the code below in an html file

4) Open the html file in the browser and see test transactions immediately

**SIMPLE, FAST, and EASY**

```
<!doctype html>
<html>

<head>
  <title>Handpoint SDK Trial Integration</title>
  <script src="handpoint.js"></script>
</head>

<body>
  <script>
      var hp = new Handpoint()
      //************* Test configuration *************//
      var apiKey = 'YourApiKey';
      var deviceName = '082245-Device';
      var environmentIsDevelopment = true;
      //*********************************************//
      hp.init(apiKey, environmentIsDevelopment, (pendingEoT) => {
        console.log('Recovered Transaction -> ' + JSON.stringify(pendingEoT));
      }).then(
        response1 => {
          console.log('Successful initialization')
          //document.writeln('Successful initialization<br />')
          hp.connect(deviceName).then(
            response2 => {
              console.log('Successful Connection to device [' + deviceName + ']');
              //document.writeln('Successful Connection to device [' + deviceName + ']<br />')
              console.log('Executing sale');
              //document.writeln('Executing sale<br />')
              hp.sale('10', 'EUR').then(
                response3 => {
                  console.log('Successful sale');
                  //document.writeln('Successful sale<br />');
                  hp.disconnect(deviceName).then(
                    response3 => {
                      console.log('Successful disconnection from device [' + deviceName + ']')
                      //document.writeln('Successful disconnection from device [' + deviceName + ']<br />')
                    }
                  ).catch(
                    error => console.log('Disconnection to device [' + deviceName + '] Failed -> ' + JSON.stringify(error))
                  );
                }
              ).catch(
                error => console.log('Sale Failed -> ' + JSON.stringify(error))
              );
            }
          ).catch(
            error => console.log('Connection to device [' + deviceName + '] Failed -> ' + JSON.stringify(error))
          );
        }
      ).catch(
        error => console.log('Initialization Failed -> ' + JSON.stringify(error))
      );
  </script>
</body>

</html>
```

## Integration Tips

Maintain the connection with the terminal at all times:
- To be able to recover a transaction result through the callback passed in the [*init*](#1) method, the point of sale and the terminal MUST be connected and online. For that reason, we recommend to connect to the target terminal and maintain the connection alive at all times instead of connecting and disconnecting for every transaction.
- Using the same connection, the user may perform as many transactions as desired. The SDK is in charge of maintaining the secure channel between the point of sale and the terminal. No connection and disconnection between transactions is required. The silent connected periods will provide the possibility for the device to deliver any pending transaction result in case of a network issue.

How Transaction Recovery Works:
- The terminal has a transaction recovery loop to automatically send back the pending [*Transaction Result*](#18) to the Point of sale in case it becomes unreachable (network issue or other). For the first 100 seconds after a transaction is completed, a background thread will attempt to deliver the result every 5 seconds. If the point of sale is still unreachable after the first 100 seconds, the retry loop turns into an exponential increment to the power of 2 (8s-16s-32s etc…). The recovery loop is reinitialized every time the Handpoint application is restarted or anytime the startRecovery method is used.

## Methods

### Initialize{#1}

`Initialize`

Initializes the JavaScript SDK and returns the list of payment terminals associated with the account.
	
**Parameters**


| Parameter      | Notes |
| ----------- | ----------- |
| `API_key *`  <br />*string*   | The Actor API key.|
| `dev_or_prod_environment *` <br />*boolean*  | Value that defines if the actor is targeting a development (true -> cloud.handpoint.io) or production (false -> cloud.handpoint.com) environment.|
| `old_EoT_callback *` <br />*function*   |Function that collects the pending EoT results that couldn't be sent to the device during the execution of the transaction. The callback input parameter is a FinancialResponse object.

**Code example**

```
Handpoint.init('API KEY', true, (pendingEoT) => {
  console.log('Recovered Transaction -> ' + JSON.stringify(pendingEoT);
  handleTransactionResultFunction(pendingEoT);
 })
```

** Returns**

**Devices**
***
List of Device objects


### Connect{#2}

`Connect`

Connect the JavaScript SDK to a payment terminal.
	
**Parameters**


| Parameter      | Notes |
| ----------- | ----------- |
| `device_name *`  <br />*string*   | The target payment terminal to connect to. The device_name is returned in the Device object of the init call.|

**Code example**

```
Handpoint.connect('1234263-TYPE1');
```

** Returns**

**Connection Result**
***
200 code for OK - 403 code for NOK

### Disconnect{#3}

`Disconnect`

Connect the JavaScript SDK to a payment terminal.
	
**Parameters**


| Parameter      | Notes |
| ----------- | ----------- |
| `device_name *`  <br />*string*   | The target payment terminal to disconnect from. The device_name is returned in the Device object of the init call.|

**Code example**

```
Handpoint.connect('1234263-TYPE1');
```

** Returns**

**Connection Result**
***
'Disconnected' message for OK - 'ERROR disconnecting' message for NOK

### Sale{#4}

`Sale`

A sale initiates a payment operation to the card reader. In its simplest form, you only have to pass the amount and currency as parameters.
	
**Parameters**


| Parameter      | Notes |
| ----------- | ----------- |
| `amount *`  <br />*integer*   | Amount of funds to charge - in the minor unit of currency (f.ex. 1000 is 10.00 GBP).|
| `currency  *`  <br />*string*   | Currency of the charge|
| `[*SaleOptions*](#23)  *`  <br />[*[*SaleOptions*](#23) *]  | An object to store all the customisation options for a sale. This object can be empty if no options are required.|
| `callback_function  *`  <br />*string*   | Callback function to subscribe to the transaction status updates.|

**Code example**

```
var [*SaleOptions*](#23)  = {
    customerReference: "MyCustomReference",
    tipConfiguration: {
        baseAmount: "100",
        skipEnabled: true,
        enterAmountEnabled: true,
        tipPercentages: [
            1,
            2,
            3,
            5
        ]
    },
    bypassOptions: {
        signatureBypass: true,
        pinBypass: true
    },
    merchantAuth: [
        {
            acquirer: "ACQUIRER",
            mid: "11111",
            tid: "22222",
            mcc: "33333"
        }
    ],
}

Handpoint.sale('1000', 'USD', [*SaleOptions*](#23) , function (stat) {
  console.log('Transaction Status received -> '+ stat.message) 
});
```

** Returns**

**Sale Response**
***
A Financial Response object

### Sale And Tokenization{#5}

`SaleAndTokenization`

A sale which both authorizes the transaction and returns a token representing the card. This feature is not available for all acquirers. Please check with Handpoint to know if tokenization is supported for your acquirer of choice.
	
**Parameters**


| Parameter      | Notes |
| ----------- | ----------- |
| `amount *`  <br />*integer*   | Amount of funds to charge - in the minor unit of currency (f.ex. 1000 is 10.00 GBP).|
| `currency  *`  <br />*string*   | Currency of the charge|
| `[*SaleOptions*](#23)  *`  <br />*[*SaleOptions*](#23) *   | An object to store all the customisation options for a sale. This object can be empty if no options are required.|
| `callback_function  *`  <br />*string*   | Callback function to subscribe to the transaction status updates.|

**Code example**

```
var [*SaleOptions*](#23)  = {
    customerReference: "MyCustomReference",
    tipConfiguration: {
        baseAmount: "100",
        skipEnabled: true,
        enterAmountEnabled: true,
        tipPercentages: [
            1,
            2,
            3,
            5
        ]
    },
    bypassOptions: {
        signatureBypass: true,
        pinBypass: true
    },
    merchantAuth: [
        {
            acquirer: "ACQUIRER",
            mid: "11111",
            tid: "22222",
            mcc: "33333"
        }
    ],
}

Handpoint.saleAndTokenization('1000', 'USD', [*SaleOptions*](#23) , CallbackFunction(stat){...});
```

** Returns**

**Sale and Tokenization Response**
***
A Financial Response object


### Transaction Recovery{#6}

`StartRecovery`

The terminal has a transaction recovery loop to automatically send back the pending [*Transaction Result*](#18) to the Point of sale in case it becomes unreachable (network issue or other).

For the first 100 seconds after a transaction is completed, a background thread will attempt to deliver the result every 5 seconds. If the point of sale is still unreachable after the first 100 seconds, the retry loop turns into an exponential increment to the power of 2 (8s-16s-32s etc…).

The recovery loop is reinitialized every time the Handpoint application is restarted or the startRecovery method is triggered.The [*Transaction Result*](#18) received through the transaction recovery loop will have the recoveredTransaction field set to true

**Important information: The point of sale must be successfully connected to a terminal in order to receive the pending transactions.**
	
**Code example**

```
//Start recovery of pending transactions 
Handpoint.startRecovery();
```

** Returns**

**Promise Successful Response**
***
The event has been sent to the device

**Promise Error Response**
***
The event was not sent to the terminal because it is unreachable

### Stop Listening Device{#7}

`StopListeningDevice`

This operation interrupts the connection, stops listening to transaction events and resets the connection with the device

	
**Code example**

```
//Stop Listening to Events 
Handpoint.stopListeningDevice();
```

### Sale Reversal{#8}

`SaleReversal`

A sale Reversal, also called sale VOID allows the user to reverse a previous sale operation. This operation reverts (if possible) a specific sale identified with a transaction id. In its simplest form, you only have to pass the amount, currency and originalTransactionID as parameters	

**Parameters**


| Parameter      | Notes |
| ----------- | ----------- |
| `amount *`  <br />*integer*   | Amount of funds to charge - in the minor unit of currency (f.ex. 1000 is 10.00 GBP).|
| `currency  *`  <br />*string*   | Currency of the charge|
| `originalTransactionID  *`  <br />*string*   | The transaction id of the original sale authorization|
| `merchantAuthOptions *`  <br />[*MerchantAuthOptions*](#25)   | An object to store all the customisation options for a saleReversal. This object can be empty if no options are required.|
| `callback_function *`  <br />*string*   | Callback function to subscribe to the transaction status updates.|

**Code example**

```
var saleReversalOptions = {
    customerReference: "MyCustomReference",
    merchantAuth: [
        {
            acquirer: "ACQUIRER",
            mid: "11111",
            tid: "22222",
            mcc: "33333"
        }
    ],
}

Handpoint.saleReversal('1000', 'USD', 'OriginalSaleGUID', saleReversalOptions, CallbackFunction(stat){...});
```

** Returns**

**Sale Reversal Response**
***
A Financial Response object

### Refund{#9}

`Refund`

A refund initiates a refund operation to the payment terminal. This operation moves funds from the merchant account to the cardholder´s credit card. In its simplest form, you only have to pass the amount and currency as parameters. For Interac (Canadian Debit Network), refunds can only be processed until Interac closes the batch of transactions at night.

**Parameters**


| Parameter      | Notes |
| ----------- | ----------- |
| `amount *`  <br />*integer*   | Amount of funds to charge - in the minor unit of currency (f.ex. 1000 is 10.00 GBP).|
| `currency  *`  <br />*string*   | Currency of the charge|
| `originalTransactionID  *`  <br />*string*   | The transaction id of the original sale authorization|
| `refundOptions *`  <br />[*RefundOptions*](#24)   | An object to store all the customisation options for a saleReversal. This object can be empty if no options are required.|
| `callback_function *`  <br />*string*   | Callback function to subscribe to the transaction status updates.|

**Code example**

```
var refundOptions = {
    customerReference: "MyCustomReference",
    bypassOptions: {
        signatureBypass: true,
        pinBypass: true
    },
    merchantAuth: [
        {
            acquirer: "ACQUIRER",
            mid: "11111",
            tid: "22222",
            mcc: "33333"
        }
    ],
}

Handpoint.refund('1000', 'USD', undefined ,refundOptions, CallbackFunction(stat){...});

// Linked Refund
Handpoint.refund('1000', 'USD', 'OriginalSaleGUID' ,refundOptions, CallbackFunction(stat){...});
```

** Returns**

**Refund Response**
***
A Financial Response object


### Refund Reversal{#10}

`RefundReversal`

A Refund Reversal, also called Refund VOID, allows the merchant to reverse a previous refund operation. This operation reverts (if possible) a specific refund identified with a transaction id. In its simplest form, you only have to pass the amount, currency and originalTransactionID as parameters.

**Parameters**


| Parameter      | Notes |
| ----------- | ----------- |
| `amount *`  <br />*integer*   | Amount of funds to charge - in the minor unit of currency (f.ex. 1000 is 10.00 GBP).|
| `currency  *`  <br />*string*   | Currency of the charge|
| `originalTransactionID  *`  <br />*string*   | The transaction id of the original sale authorization|
| `merchantAuthOptions *`  <br />[*MerchantAuthOptions*](#25)   | An object to store all the customisation options for a refundReversal. This object can be empty if no options are required.|
| `callback_function *`  <br />*string*   | Callback function to subscribe to the transaction status updates.|

**Code example**

```
var refundOptions = {
    customerReference: "MyCustomReference",
    bypassOptions: {
        signatureBypass: true,
        pinBypass: true
    },
    merchantAuth: [
        {
            acquirer: "ACQUIRER",
            mid: "11111",
            tid: "22222",
            mcc: "33333"
        }
    ],
}

Handpoint.refund('1000', 'USD', undefined ,refundOptions, CallbackFunction(stat){...});

// Linked Refund
Handpoint.refund('1000', 'USD', 'OriginalSaleGUID' ,refundOptions, CallbackFunction(stat){...});
```

** Returns**

**Refund Reversal Response**
***
A Financial Response object


### Tokenize Card{#11}

`TokenizeCard`

Returns a token for the card. This feature is not available for all acquirers. Please check with Handpoint to know if tokenization is supported for your acquirer of choice

**Parameters**


| Parameter      | Notes |
| ----------- | ----------- |
| `options *`  <br />[*Options*](#26)   | An object to store all the customisation options for a tokenizeCard. This object can be empty if no options are required.|
| `callback_function *`  <br />*string*   | Callback function to subscribe to the transaction status updates.|

**Code example**

```
var options = {
    customerReference: "MyCustomReference",
}

Handpoint.tokenizeCard(options, CallbackFunction(stat){...});
```

** Returns**

**Tokenize Card Response**
***
A Financial Response object


### Card Pan{#12}

`CardPan`

A cardPan request will return the full PAN of the card being swiped, dipped or tapped. Only the PANs of whitelisted card ranges will be returned by the Handpoint systems. This operation is mostly used to be able to process funds or points from loyalty cards.

**Parameters**


| Parameter      | Notes |
| ----------- | ----------- |
| `options *`  <br />[*Options*](#26)   | An object to store all the customisation options for a tokenizeCard. This object can be empty if no options are required.|
| `callback_function *`  <br />*string*   | Callback function to subscribe to the transaction status updates.|

**Code example**

```
var options = {
    customerReference: "MyCustomReference",
}

Handpoint.tokenizeCard(options, CallbackFunction(stat){...});
```

** Returns**

**Card Pan Response**
***
A Financial Response object

### Stop Current Transaction{#13}

`StopCurrentTransaction`

Operation used to stop the current transaction. The transaction can only be stopped at specific stages of a payment processing, for example a transaction can not be stopped when the card is being read but can be stopped when waiting for the cardholder to initially insert a card.


**Code example**

```
Handpoint.stopCurrentTransaction();

```

** Returns**

**Promise Successful Response**
***
{ finStatus: CANCELLED, statusMessage: 'Operation stopped' }
**Promise Error Response**
***
{ finStatus: FAILED, errorMessage: 'Unable to stop current transaction' }
**Promise Error Response**
***
{ finStatus: FAILED, errorMessage: 'No response received from the card reader' }

### Print Receipt{#14}

`PrintReceipt`

This method sends the merchant or customer receipt to the terminal for printing. The format of the HTML data, passed to the method or stored in the url, must follow this format: Html Print Format.


**Code example**

```
Handpoint.printReceipt('https://location_of_receipt_container.com/receipt_location', CallbackFunction(stat){...});

var htmlReceipt = '[...] HTML receipt [...]'

Handpoint.printReceipt(htmlReceipt, CallbackFunction(stat){...});
```
**Parameters**

| Parameter      | Notes |
| ----------- | ----------- |
| `receipt *`  <br />*string*   | HTML receipt or url to locate the receipt, it can be found in the response of a financial operation, in the fields merchantReceipt or customerReceipt|
| `callback_function *`  <br />*string*   | Callback function to subscribe to the transaction status updates.|

** Returns**

**Print Receipt Response**
***
A specific Status object that describes the printing action (PrinterOutOfPaper, ErrorConnectingToPrinter or ReceiptPrintSuccess)

### Ping Device{#15}

`PingDevice`

This operation will ping the terminal to confirm if it is online. The promise is correctly resolved if the device is online and successfully answers to the ping

**Code example**

```
Handpoint.pingDevice(CallbackFunction(stat){...});
```

** Returns**

**Device Status**
***
A [*Device Status*](#27) object

### Update{#16}

`Update`

Triggers a terminal software and config update

**Code example**

```
Handpoint.update(CallbackFunction(stat){...});
```

**Parameters**


| Parameter      | Notes |
| ----------- | ----------- |
| `callback_function *`  <br />*string*   | Callback function to subscribe to the transaction status updates.|

** Returns**

**Update Response**
***
A Financial Response object

## Objects

### Merchant Auth{#17}

`MerchantAuth`

Object used to store merchant authentication. This object can be empty, it allows a transaction to be funded to a specific merchant account other than the default one. It is useful if a terminal is shared between multiple merchants, for example at an Hair Salon or a Doctor's office.

**Code example**

```
{
   "merchantAuth": [{
       "acquirer": "ACQ_DUMMY",
       "mid": "1111",
       "tid": "2222",
       "mcc": "3333",
       "externalId": "4444"
       }]
}
```

**Properties**

| Property      | Description |
| ----------- | ----------- |
| `Credential`  <br />[*Credential[]*](#28)   | Array of credentials|

### Transaction Result Object{#18}

`TransactionResult`

An object holding information about the result of a transaction.

**Code example**

```
{
  "aid": "A0000000041010",
  "arc": "0000",
  "authorisationCode": "123456",
  "balance": null,
  "budgetNumber": "",
  "cardEntryType": "UNDEFINED",
  "cardLanguagePreference": "",
  "cardSchemeName": "MasterCard",
  "cardToken": "",
  "chipTransactionReport": "",
  "currency": "USD",
  "customerReceipt": "https://s3.[...]/customerReceipt.html",
  "customerReference": "",
  "deviceStatus": {
      "applicationName": "ClientApp",
      "applicationVersion": "20.1.0",
      "batteryCharging": "Not Charging",
      "batteryStatus": "100",
      "batterymV": "4126",
      "bluetoothName": "PAXA920",
      "externalPower": "USB",
      "serialNumber": "0821032398",
      "statusMessage": "Approved or completed successfully"
  },
  "dueAmount": 0,
  "errorMessage": "",
  "expiryDateMMYY": "0422",
  "finStatus": "AUTHORISED",
  "iad": "0210A000002A0000000000000000000000FF",
  "issuerResponseCode": "00",
  "maskedCardNumber": "************1456",
  "merchantAddress": "Plaza Soledad Torres Acosta 1 28013 Madrid",
  "merchantName": "Hago la cama",
  "merchantReceipt": "https://s3.[...]/merchantReceipt.html",
  "mid": "",
  "originalEFTTransactionID": "",
  "paymentScenario": "CHIPCONTACTLESS",
  "rrn": "",
  "signatureUrl": "",
  "statusMessage": "Approved or completed successfully",
  "tenderType": "CREDIT",
  "tid": "ACQUIRER_TID",
  "tipAmount": 0,
  "totalAmount": 100,
  "transactionID": "01236fc0-8192-11eb-9aca-ad4b0e95f241",
  "tsi": "0000",
  "tvr": "0400008001",
  "type": "SALE",
  "unMaskedPan": "",
  "verificationMethod": "UNDEFINED",
  "efttimestamp": 1615374961000,
  "efttransactionID": "01236fc0-8192-11eb-9aca-ad4b0e95f241",
  "requestedAmount": 100,
  "tipPercentage": 0,
  "recoveredTransaction": false,
  "cardHolderName": "cardholder name"
}
```

**Properties**

| Property      | Description |
| ----------- | ----------- |
| `aid`  <br />*String	*   | Application Identifier of the card (EMV tag 9F06)|
| `arc`  <br />*String	*   | EMV Authorisation Response Code (EMV tag 8A)|
| `authorisationCode`  <br />*String	*   | Application Identifier of the card (EMV tag 9F06)|
| `balance`  <br />*BigInteger	*   | Balance available on the card|
| `budgetNumber`  <br />*String	*   | Used to split payments over a period of months|
| `cardEntryType`  <br />[*CardEntryType*](#29)   | Method used by the terminal to read the card|
| `cardLanguagePreference`  <br />*String	*   | Preferred language of the card (EMV tag 5F2D)|
| `cardSchemeName`  <br />[*CardSchemeName*](#30)   | The brand of the card|
| `cardToken`  <br />*String	*   | Token representing the PAN of the card|
| `chipTransactionReport`  <br />*String	*   | 	Full report of the card EMV parameters|
| `currency`  <br />[*Currency*](#31)   | The currency used for the transaction|
| `customerReceipt`  <br />*String	*   | 	A URL containing the customer receipt in HTML format|
| `customerReference`  <br />*String	*   | If a customerReference was provided as an optional parameter in the transaction request it is echoed unaltered in this field|
| `deviceStatus`  <br />[*DeviceStatus*](#27)  | Status of the device|
| `dueAmount`  <br />*String	*   | In case of a partial approval for the transaction, this field contains the amount which remains to be paid|
| `efttimestamp`  <br />*String	*   | Time of the transaction|
| `efttransactionID`  <br />*String	*   | Handpoint unique identifier for a transaction, this id is the one to be used for a transaction to be reversed.|
| `errorMessage`  <br />*String	*   | Detailed reason for the transaction error|
| `expiryDateMMYY`  <br />*String	*   | Expiry date of the card used for the operation|
| `finStatus`  <br />[*FinancialStatus*](#33)   | The financial status contains the outcome of the transaction. For example "AUTHORISED" or "DECLINED"|
| `iad`  <br />*String	*   | Issuer Application Data (EMV tag 9F10)|
| `issuerResponseCode`  <br />*String	*   | Response code from the card issuer|
| `maskedCardNumber`  <br />*String	*   | Masked card number of the card used for the operation|
| `merchantAddress`  <br />*String	*   | Merchant Address|
| `merchantName`  <br />*String	*   | Merchant Name|
| `merchantReceipt`  <br />*String	*   | A URL containing the customer receipt in HTML format|
| `mid`  <br />*String	*   | Merchant Identifier|
| `originalEFTTransactionID`  <br />*String	*   | In case the transaction type is a reversal, this field will contain the identifier of the original transaction being reversed|
| `paymentScenario`  <br />[*PaymentScenario*](#34)   | Indicates the card entry mode|
| `recoveredTransaction`  <br />*String	*   | This flag is set to true if the transaction result is sent through the transaction recovery logic explained in the Recovey Section, false otherwise|
| `requestedAmount`  <br />*String	*   | The requested amount is the transaction amount sent to the terminal|
| `rrn`  <br />*String	*   | Retrieval Reference Number, unique number assigned by the acquirer|
| `signatureUrl`  <br />*String	*   | If a digital signature is required, this is the URL containing the image of the captured signature|
| `statusMessage`  <br />*String	*   | The status of the transaction, for example "Waiting for pin"|
| `tenderType`  <br />[*TenderType*](#35)   | Transaction tender type (credit / debit)|
| `tid`  <br />*String	*   | Terminal Identifier|
| `tipAmount`  <br />*String	*   | Tip amount, if any, in the minor unit of currency (f.ex. 1000 is 10.00 GBP)|
| `tipPercentage`  <br />*String	*   | If tipping is enabled, this field will return the tip percentage added on top of the base amount|
| `totalAmount`  <br />*String	*   | The total amount is the amount the card was charged for. It is possible that the total amount is not the same as the requested amount since an additional fee can be added, with the customer's approval, via the tipping functionality|
| `transactionID`  <br />*String	*   | The transaction id is a terminal internal counter incremented for each transaction|
| `tsi`  <br />*String	*   | Transaction Status Information (EMV tag 9B)|
| `tvr`  <br />*String	*   | Transaction Verification Results (EMV tag 95)|
| `type`  <br />[*TransactionType*](#36)   | 	The type of transaction initiated, for example "SALE"|
| `unMaskedPan`  <br />*String	*   | Unmasked PAN, only received if the card is a non-payment card (loyalty)|
| `verificationMethod`  <br />[*VerificationMethod*](#37)   | cardholder verification method, for example "PIN"|
| `multiLanguageStatusMessages`  <br />*Map	*   | `map` containing the status message in a human readable format for all the supported locales.|
| `multiLanguageErrorMessages`  <br />*Map	*   | `map` containing the error message in a human readable format for all the supported locales.|
| `cardHolderName`  <br />*String	*   | Name of the cardholder|

### Bypass Options{#19}

`BypassOptions`

Configuration to enable/disable signature or pin bypass.

**Code example**

```
{
   "bypassOptions": {
       "signatureBypass": true,
       "pinBypass": true
       }
}
```

**Properties**

| Property      | Description |
| ----------- | ----------- |
| `pinBypass`  <br />*Boolean*   | Bypasses PIN entry when the shopper says they don't know the PIN for the card and the merchant either knows they are the legitimate cardholder or want to give them the benefit of the doubt. PIN Bypass should be set to True if you want to enable pin bypass for a transaction|
| `signatureBypass`  <br />*Boolean*   | Whether the terminal prompts for a signature, depends on how you configure this. The major card schemes (American Express, Diners, Discover, JCB, Mastercard, Visa, UnionPay) no longer require a signature; they regard it as optional for card-present transactions. This means you can speed up your checkout by skipping the signature prompt. But if your business requires it, you can still let the terminal prompt for a signature. The shopper then provides their signature on the touch screen of the terminal or on the printed transaction receipt. This depends on how you configure this setting. It is your responsibility to verify the signature of the shopper with the signature on the card or another form of identification. Signature Bypass should be set to True if you want to enable signature for this transaction|



### Device{#20}

`Device`

An object to store the information about the payment terminal you are working with. ALL values are **REQUIRED**


**Code example**

```
{
       "merchant_id_alpha": "Test_Merchant",
       "serial_number": "614004878",
       "ssk": "74817EA5C63437ADE7AA3A5401",
       "terminal_type": "PAXA920",
       "device_name": "0821032395-PAXA920"
}
```

**Properties**

| Property      | Description |
| ----------- | ----------- |
| `merchant_id_alpha`  <br />*String*   | Merchant unique identifier to which the device is associated|
| `serial_number`  <br />*String*   | Device serial number|
| `ssk`  <br />*String*   | Device shared secret key to authorize the operations.|
| `terminal_type`  <br />*String*   | Device type|
| `device_name`  <br />*String*   | Device name composed with serial_number - terminal_type|

### Acquirer{#21}

`Acquirer`

An enum representingbthe supported acquirers for merchant authentication

`AMEX` `BORGUN` `EVO` `OMNIPAY` `POSTBRIDGE` `INTERAC` `TSYS` `VANTIV` `SANDBOX`

### Transaction Status{#22}

`TransactionStatus`

A class that holds the device status. This is the object that will be recieved in the financial operation callback functions


**Properties**

| Property      | Description |
| ----------- | ----------- |
| `deviceStatus`  <br />[*Device Status*](#27)   | OPTIONAL - The status of the payment terminal.|
| `isCancelAllowed`  <br />*boolean*   | defines is a transaction can be cancelled or not.|
| `message`  <br />*String*   | Human readable status message.|
| `status`  <br />[*status*](#38)  | An enum containing information about the status of the transaction.|

### Sale Options{#23}

`SaleOptions`

An object to store all the customisation options for an operation. This object can be empty if no options are required.

**Code example**

```
{
    "customerReference": "MyCustomReference",
    "tipConfiguration": {
        "baseAmount": "100",
        "skipEnabled": true,
        "enterAmountEnabled": true,
        "tipPercentages": [
            1,
            2,
            3,
            5
        ]
    },
    "bypassOptions": {
        "signatureBypass": true,
        "pinBypass": true
    },
    "merchantAuth": [
        {
            "acquirer": "ACQUIRER",
            "mid": "11111",
            "tid": "22222",
            "mcc": "33333"
        }
    ],
}
```	

**Properties**

| Property      | Description |
| ----------- | ----------- |
| `customerReference`  <br />*String*   | An arbitrary string to use as your own identifier for a transaction|
| `TipConfiguration`  <br />[*TipConfiguration*](#39) |
| `bypassOptions`  <br />[*BypassOptions*](#19) |  
| `merchantAuth`  <br />[*MerchantAuth*](#17)   |

### Refund Options{#24}

`RefundOptions`

An object to store all the customisation options for a refund. This object can be empty if no options are required.

**Code example**

```
{
    "customerReference": "MyCustomReference",
    "tipConfiguration": {
        "baseAmount": "100",
        "skipEnabled": true,
        "enterAmountEnabled": true,
        "tipPercentages": [
            1,
            2,
            3,
            5
        ]
    },
    "bypassOptions": {
        "signatureBypass": true,
        "pinBypass": true
    },
    "merchantAuth": [
        {
            "acquirer": "ACQUIRER",
            "mid": "11111",
            "tid": "22222",
            "mcc": "33333"
        }
    ],
}
```	

**Properties**

| Property      | Description |
| ----------- | ----------- |
| `customerReference`  <br />*String*   | An arbitrary string to use as your own identifier for a transaction|
| `bypassOptions`  <br />[*BypassOptions*](#19) |
| `merchantAuth`  <br />[*MerchantAuth*](#17) |

### Merchant Auth Options{#25}

`MerchantAuthOptions`

An object to store merchant authentication options for regular operations.

**Code example**

```
{
    "customerReference": "MyCustomReference",
    "merchantAuth": [
        {
            "acquirer": "ACQUIRER",
            "mid": "11111",
            "tid": "22222",
            "mcc": "33333"
        }
    ],
}
```	

**Properties**

| Property      | Description |
| ----------- | ----------- |
| `customerReference`  <br />*String* |
| `merchantAuth`  <br />[*MerchantAuth*](#17) |

### Options{#26}

`Options`

An object to store all the customisation options for an operation. This object can be empty if no options are required.

**Code example**

```
{
    "customerReference": "MyCustomReference",
    "merchantAuth": [
        {
            "acquirer": "ACQUIRER",
            "mid": "11111",
            "tid": "22222",
            "mcc": "33333"
        }
    ],
}
```	

**Properties**

| Property      | Description |
| ----------- | ----------- |
| `customerReference`  <br />*String*   | An arbitrary string to use as your own identifier for a transaction|

### Merchant Auth Credential{#28}

`Credential`

An object to store credentials (Acquirer, Mid, Tid, MCC and ExternalId) for merchant authentication.

**Properties**

| Property      | Description |
| ----------- | ----------- |
| `acquirer`  <br />[*Acquirer*](#21)   | If present, it links this credential to the specified acquirer. Required if more than one credential is provided.|
| `mid`  <br />*String*   | For this transaction, overrides the default MID (merchant ID) saved in the terminal configuration.|
| `tid`  <br />*String*   | 	For this transaction, overrides the default TID (terminal ID) saved in the terminal configuration.|
| `mcc`  <br />*String*   | Merchant Category Code, overrides the default MCC saved in the terminal configuration.|
| `ExternalId`  <br />*String*   | For this transaction, the External Id will be used to lookup the credential of the merchant in the Handpoint backend and process the transaction accordingly. The External id replaces the need to pass MID/TID/MCC as credentials|


**Code example**
```
{
    "acquirer": "ACQ_DUMMY",
    "mid": "1111",
    "tid": "2222",
    "mcc": "3333"
}

{
    "externalId": "4444"
}
```

### Financial Status{#33}

`FinancialStatus`

An enum representing different statuses of a finalized transaction

**Possible values**

`UNDEFINED` `AUTHORISED` `DECLINED` `PROCESSED` `FAILED` `CANCELLED` `PARTIAL_APPROVAL`

### Device Status{#27}

`DeviceStatus`

A class that holds the device status.

**Properties**

| Property      | Description |
| ----------- | ----------- |
| `SerialNumber`  <br />*String	*   | The serial number of the device|
| `BatteryStatus`  <br />*String	*   | The battery status in percentages of a device|
| `BatterymV`  <br />*String	*   | The battery milli volts of a device|
| `BatteryCharging`  <br />*String	*   | 	The battery charging status of a device|
| `ExternalPower`  <br />*String	*   | The status of an external power of a device|
| `ApplicationName`  <br />*String	*   | The application name used on a device|
| `ApplicationVersion`  <br />*String	*   | The application version number used on a device|
| `bluetoothName`  <br />*String	*   | The bluetooth interface name used on a device|
| `statusMessage`  <br />*String	*   | Device human readable status message|

**Code example**
```
{
    "applicationName": "TestApp",
    "applicationVersion": "20.1.0.1",
    "batteryCharging": "Charging",
    "batteryStatus": "100",
    "batterymV": "4134",
    "bluetoothName": "A920",
    "externalPower": "USB",
    "serialNumber": "0821032397",
    "statusMessage": "Card reader time out"
}
```

### Currency{#31}

`Currency`

An enum of most currencies in the world.

Contains the ISO name, ISO number and the name of the currency. Additionally contains information about how many decimals the currency uses.

**Possible values**

`AED` `AFN` `ALL` `AMD` `ANG` `AOA` `ARS` `AUD` `AWG` `AZN` `BAM` `BBD` `BDT` `BGN` `BHD` `BIF` `BMD` `BND` `BOB` `BOV` `BRL` `BSD` `BTN` `BWP` `BYR` `BZD` `CAD` `CDF` `CHF` `CLP` `CNY` `COP` `COU` `CRC` `CUC` `CUP` `CVE` `CZK` `DJF` `DKK` `DOP` `DZD` `EEK` `EGP` `ERN` `ETB` `EUR` `FJD` `FKP` `GBP` `GEL` `GHS` `GIP` `GMD` `GNF` `GTQ` `GYD` `HKD` `HNL` `HRK` `HTG` `HUF` `IDR` `ILS` `INR` `IQD` `IRR` `ISK` `JMD` `JOD` `JPY` `KES` `KGS` `KHR` `KMF` `KPW` `KRW` `KWD` `KYD` `KZT` `LAK` `LBP` `LKR` `LRD` `LSL` `LTL` `LVL` `LYD` `MAD` `MDL` `MKD` `MMK` `MNT` `MOP` `MUR` `MVR` `MWK` `MXN` `MXV` `MYR` `MZN` `NAD` `NGN` `NIO` `NOK` `NPR` `NZD` `OMR` `PAB` `PEN` `PGK` `PHP` `PKR` `PLN` `PYG` `QAR` `RON` `RSD` `RUB` `RWF` `SAR` `SBD` `SCR` `SDG` `SEK` `SGD` `SHP` `SLL` `SOS` `SRD` `STD` `SYP` `SZL` `THB` `TJS` `TMT` `TND` `TOP` `TRY` `TTD` `TWD` `TZS` `UAH` `UGX` `USD` `UZS` `VEF` `VND` `VUV` `WST` `XAF` `XCD` `XOF` `XPF` `YER` `ZAR` `ZMK` `ZWL`

### Card Entry Type{#29}

`CardEntryType`

An enum representing different card entry types.

**Possible values**

`UNDEFINED` `MSR` `ICC` `CNP`

### Card Scheme Name{#30}

`CardSchemeName`

A string representing different card brands.

**Possible values**

`MasterCard` `Visa` `Maestro` `American Express` `Discover` `JCB` `Diners` `UnionPay`

### Verification Method{#37}

`VerificationMethod`

An enum representing different verification methods used in the transaction.

**Possible values**

`UNDEFINED` `SIGNATURE` `PIN` `PIN_SIGNATURE` `FAILED` `NOT_REQUIRED` `MOBILE_PASS_CODE`

### Payment Scenario{#34}

`PaymentScenario`

An enum representing different types of scenario.

**Possible values**

`UNKNOWN` `MAGSTRIPE` `MAGSTRIPECONTACTLESS` `CHIP` `CHIPCONTACTLESS` `CHIPFAILMAGSTRIPE`

### Status Info

`statusInfo`

A class containing information about the status of the transaction.

**Properties**

| Property      | Description |
| ----------- | ----------- |
| `cancelAllowed`  <br />*bool*   | A `boolean` letting the integrator know if the terminal will accept a stop transaction request.|
| `status`  <br />[*status*](#38)  | A Status enum representing the status of the transaction.|
| `message`  <br />*String*   | A String containing the status message of the transaction.|
| `deviceStatus`  <br />[*Device Status*](#27)   | A `DeviceStatus` object containing information about the payment terminal.|


### Status{#38}

`status`

An enum containing information about the status of a transaction.

**Possible values**

`Undefined` `Success` `InvalidData` `ProcessingError` `CommandNotAllowed` `NotInitialised` `ConnectTimeout` `ConnectError` `SendingError` `ReceivingError` `NoDataAvailable` `TransactionNotAllowed` `UnsupportedCurrency` `NoHostAvailable` `CardReaderError` `CardReadingFailed` `InvalidCard` `InputTimeout` `UserCancelled` `InvalidSignature` `WaitingForCard` `CardInserted` `ApplicationSelection` `ApplicationConfirmation` `AmountValidation` `PinInput` `ManualCardInput` `WaitingForCardRemoval` `TipInput` `SharedSecretInvalid` `SharedSecretAuth` `WaitingSignature` `WaitingHostConnect` `WaitingHostSend` `WaitingHostReceive` `WaitingHostDisconnect` `PinInputCompleted` `PosCancelled` `RequestInvalid` `CardCancelled` `CardBlocked` `RequestAuthTimeout` `RequestPaymentTimeout` `ResponseAuthTimeout` `ResponsePaymentTimeout` `IccCardSwiped` `RemoveCard` `ScannerIsNotSupported` `ScannerEvent` `BatteryTooLow` `AccountTypeSelection` `BtIsNotSupported` `PaymentCodeSelection` `PartialApproval` `AmountDueValidation` `InvalidUrl` `WaitingCustomerReceipt` `PrintingMerchantReceipt` `PrintingCustomerReceipt` `UpdateStarted` `UpdateFinished` `UpdateFailed` `UpdateProgress` `WaitingHostPostSend` `WaitingHostPostReceive` `Rebooting` `PrinterOutOfPaper` `ErrorConnectingToPrinter` `CardTapped` `ReceiptPrintSuccess` `InvalidPinLength` `OfflinePinAttempt` `OfflinePinLastAttempt` `ProcessingSignature` `CardRemoved` `TipEntered` `CardLanguagePreference` `AutomaticPrintingStarted` `CancelOperationNotAllowed` `UpdateSoftwareStarted` `UpdateSoftwareFinished` `UpdateSoftwareFailed` `UpdateSoftwareProgress` `InstallSoftwareStarted` `InstallSoftwareFinished` `InstallSoftwareFailed` `InstallSoftwareProgress` `UpdateConfigStarted` `UpdateConfigFinished` `UpdateConfigFailed` `UpdateConfigProgress` `InitialisationComplete`

### Tender Type{#35}

`TenderType`

An enum representing different tender types.

**Possible values**

`NOT_SET` `CREDIT` `DEBIT`

### Tip Configuration{#39}

`TipConfiguration`

**Properties**

| Property      | Description |
| ----------- | ----------- |
| `baseAmount`  <br />*BigInteger*   | Base amount used to calculate the tip - in the minor unit of currency (f.ex. 1000 is 10.00 GBP). If no base amount is defined, the transaction amount is used as base amount.|
| `headerName`  <br />*String*   | Name of the tipping menu appearing on the terminal. Default: Tip|
| `tipPercentages`  <br />`List<Integer>`   | List of percentages used to calculate the tip amount. **REQUIRED**|
| `enterAmountEnabled`  <br />*Boolean*   | Flag used to enable the cardholder to manually enter the tip amount. Default: true|
| `skipEnabled`  <br />*Boolean*   | Flag used to enable the cardholder to skip the tipping step. Default: true|
| `footer`  <br />*String*   | Footer note which will appear on the tipping menu. Default: Empty string|

**Code example**
```
{
    baseAmount: '2000',
    tipPercentages: [5,10,15,20,25],
    enterAmountEnabled: true,
    skipEnabled: false,
    footer: 'Thank you!!! ;)'
}
```

### Transaction Type(#36)

`TransactionType`

An enum representing different types of transactions.

**Possible values**

`UNDEFINED` `SALE` `VOID_SALE` `REFUND` `VOID_REFUND` `CANCEL_SALE` `CANCEL_REFUND` `TOKENIZE_CARD` `CARD_PAN`
